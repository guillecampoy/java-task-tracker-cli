package tasktracker.infra;

import tasktracker.domain.Task;
import tasktracker.domain.TaskRepository;
import tasktracker.domain.TaskStatus;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JsonFileTaskRepository implements TaskRepository {

    private final Path filePath;

    public JsonFileTaskRepository(String fileName) {
        this.filePath = Paths.get(fileName);
    }

    @Override
    public List<Task> findAll() {
        return loadAll();
    }

    @Override
    public Optional<Task> findById(int id) {
        return loadAll().stream()
                .filter(t -> t.id() == id)
                .findFirst();
    }

    @Override
    public Task save(Task task) {
        List<Task> all = new ArrayList<>(loadAll());
        all.removeIf(t -> t.id() == task.id());
        all.add(task);
        saveAll(all);
        return task;
    }

    @Override
    public void deleteById(int id) {
        List<Task> all = new ArrayList<>(loadAll());
        all.removeIf(t -> t.id() == id);
        saveAll(all);
    }

    @Override
    public int getNextId() {
        return loadAll().stream()
                .mapToInt(Task::id)
                .max()
                .orElse(0) + 1;
    }

    // ------------------------
    // JSON <-> Task helpers
    // ------------------------

    private List<Task> loadAll() {
        if (!Files.exists(filePath)) {
            return new ArrayList<>();
        }
        try {
            String json = Files.readString(filePath).trim();
            if (json.isEmpty() || json.equals("[]")) {
                return new ArrayList<>();
            }
            return parseTasks(json);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read tasks file", e);
        }
    }

    private void saveAll(List<Task> tasks) {
        try {
            String json = toJson(tasks);
            Files.writeString(
                    filePath,
                    json,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING
            );
        } catch (IOException e) {
            throw new RuntimeException("Failed to write tasks file", e);
        }
    }

    /**
     * Serialize a list of tasks to a JSON array string.
     */
    private String toJson(List<Task> tasks) {
        StringBuilder sb = new StringBuilder();
        sb.append("[\n");

        for (int i = 0; i < tasks.size(); i++) {
            Task t = tasks.get(i);
            sb.append("  {\n");
            sb.append("    \"id\": ").append(t.id()).append(",\n");
            sb.append("    \"description\": \"").append(escapeJson(t.description())).append("\",\n");
            sb.append("    \"status\": \"").append(t.status().name()).append("\",\n");
            sb.append("    \"createdAt\": \"").append(t.createdAt().toString()).append("\",\n");
            sb.append("    \"updatedAt\": \"").append(t.updatedAt().toString()).append("\"\n");
            sb.append("  }");
            if (i < tasks.size() - 1) {
                sb.append(",");
            }
            sb.append("\n");
        }

        sb.append("]");
        return sb.toString();
    }

    /**
     * Very small JSON helper to escape a few characters.
     * This is not a full JSON implementation, but is enough
     * for our own controlled input.
     */
    private String escapeJson(String text) {
        if (text == null) {
            return "";
        }
        StringBuilder sb = new StringBuilder(text.length() + 16);
        for (char c : text.toCharArray()) {
            switch (c) {
                case '\\' -> sb.append("\\\\");
                case '"' -> sb.append("\\\"");
                case '\n' -> sb.append("\\n");
                case '\r' -> sb.append("\\r");
                case '\t' -> sb.append("\\t");
                default -> {
                    if (c < 0x20) {
                        // control characters
                        sb.append(String.format("\\u%04x", (int) c));
                    } else {
                        sb.append(c);
                    }
                }
            }
        }
        return sb.toString();
    }

    /**
     * Parse a JSON array of tasks previously generated by toJson().
     * This is a very small, format-dependent parser (no external libs).
     */
    private List<Task> parseTasks(String json) {
        List<Task> result = new ArrayList<>();

        // Remove [ ... ] and work on inner content
        String trimmed = json.trim();
        if (!trimmed.startsWith("[") || !trimmed.endsWith("]")) {
            throw new IllegalStateException("Invalid JSON format for tasks array.");
        }
        String inner = trimmed.substring(1, trimmed.length() - 1).trim();
        if (inner.isEmpty()) {
            return result;
        }

        // Split into individual object JSON sections using brace depth
        List<String> objects = splitJsonObjects(inner);

        for (String objJson : objects) {
            result.add(parseTask(objJson));
        }

        return result;
    }

    /**
     * Split a string containing multiple JSON objects (separated by commas)
     * into a list of single-object JSON strings.
     */
    private List<String> splitJsonObjects(String inner) {
        List<String> objects = new ArrayList<>();

        int depth = 0;
        int start = -1;
        for (int i = 0; i < inner.length(); i++) {
            char c = inner.charAt(i);
            if (c == '{') {
                if (depth == 0) {
                    start = i;
                }
                depth++;
            } else if (c == '}') {
                depth--;
                if (depth == 0 && start >= 0) {
                    String obj = inner.substring(start, i + 1);
                    objects.add(obj.trim());
                    start = -1;
                }
            }
        }

        return objects;
    }

    /**
     * Parse a single task JSON object into a Task instance.
     * Assumes the JSON format generated by toJson().
     */
    private Task parseTask(String objJson) {
        int id = Integer.parseInt(extractNumberField(objJson, "id"));
        String description = unescapeJson(extractStringField(objJson, "description"));
        String statusStr = extractStringField(objJson, "status");
        TaskStatus status = TaskStatus.valueOf(statusStr);

        String createdAtStr = extractStringField(objJson, "createdAt");
        String updatedAtStr = extractStringField(objJson, "updatedAt");

        LocalDateTime createdAt = LocalDateTime.parse(createdAtStr);
        LocalDateTime updatedAt = LocalDateTime.parse(updatedAtStr);

        return new Task(id, description, status, createdAt, updatedAt);
    }

    private String extractNumberField(String json, String fieldName) {
        Pattern pattern = Pattern.compile("\"" + Pattern.quote(fieldName) + "\"\\s*:\\s*(\\d+)");
        Matcher matcher = pattern.matcher(json);
        if (!matcher.find()) {
            throw new IllegalStateException("Field '" + fieldName + "' not found in JSON: " + json);
        }
        return matcher.group(1);
    }

    private String extractStringField(String json, String fieldName) {
        Pattern pattern = Pattern.compile("\"" + Pattern.quote(fieldName) + "\"\\s*:\\s*\"(.*?)\"");
        Matcher matcher = pattern.matcher(json);
        if (!matcher.find()) {
            throw new IllegalStateException("Field '" + fieldName + "' not found in JSON: " + json);
        }
        return matcher.group(1);
    }

    /**
     * Reverse of escapeJson() for the subset we use.
     */
    private String unescapeJson(String text) {
        StringBuilder sb = new StringBuilder(text.length());
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (c == '\\' && i + 1 < text.length()) {
                char next = text.charAt(i + 1);
                switch (next) {
                    case '\\' -> { sb.append('\\'); i++; }
                    case '"' -> { sb.append('"'); i++; }
                    case 'n' -> { sb.append('\n'); i++; }
                    case 'r' -> { sb.append('\r'); i++; }
                    case 't' -> { sb.append('\t'); i++; }
                    case 'u' -> {
                        if (i + 5 < text.length()) {
                            String hex = text.substring(i + 2, i + 6);
                            int codePoint = Integer.parseInt(hex, 16);
                            sb.append((char) codePoint);
                            i += 5;
                        } else {
                            sb.append(next); // best effort
                            i++;
                        }
                    }
                    default -> {
                        // Unknown escape, keep as-is 
                        sb.append(next);
                        i++;
                    }
                }
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

}
